// scripts/content-bridge.js
const fs = require('fs-extra');
const path = require('path');
const matter = require('gray-matter');
const MarkdownIt = require('markdown-it');

const md = new MarkdownIt({
  html: true,
  linkify: true,
  typographer: true
});

class InertiaContentBridge {
  constructor() {
    this.vaultPath = '/Users/erhei/Library/CloudStorage/ProtonDrive-xerah@pm.me-folder/inertia-vault';
    this.websitePath = '/Users/erhei/Library/CloudStorage/ProtonDrive-xerah@pm.me-folder/inertia-website';
    this.contentPath = path.join(this.websitePath, 'src/content');
    
    // Mapping from vault structure to website structure
    this.contentMapping = {
      'Products/Insight': 'products/insight',
      'Products/Catalyst': 'products/catalyst',
      'Products/Axis': 'products/axis',
      'Technology': 'technology',
      'Business': 'about',
      'Daily-Operations': 'blog'
    };
  }

  async initialize() {
    console.log('🚀 Initializing Inertia Content Bridge...');
    
    // Ensure content directories exist
    await fs.ensureDir(this.contentPath);
    await fs.ensureDir(path.join(this.contentPath, 'products'));
    await fs.ensureDir(path.join(this.contentPath, 'technology'));
    await fs.ensureDir(path.join(this.contentPath, 'about'));
    await fs.ensureDir(path.join(this.contentPath, 'blog'));
    
    console.log('✅ Content directories created');
  }

  async syncVaultToWebsite() {
    console.log('🔄 Starting vault to website sync...');
    
    try {
      // Check if vault exists
      if (!(await fs.pathExists(this.vaultPath))) {
        console.log('❌ Vault path not found. Please check the path.');
        return;
      }

      await this.initialize();
      
      // Process each content area
      for (const [vaultDir, webDir] of Object.entries(this.contentMapping)) {
        await this.processVaultDirectory(vaultDir, webDir);
      }
      
      // Generate special pages
      await this.generateProductOverview();
      await this.generateHomePage();
      
      console.log('✅ Sync complete!');
      
    } catch (error) {
      console.error('❌ Sync failed:', error.message);
    }
  }

  async processVaultDirectory(vaultDir, webDir) {
    const vaultDirPath = path.join(this.vaultPath, vaultDir);
    const webDirPath = path.join(this.contentPath, webDir);
    
    console.log(`📁 Processing ${vaultDir}...`);
    
    try {
      if (!(await fs.pathExists(vaultDirPath))) {
        console.log(`⚠️  Directory ${vaultDir} not found, skipping...`);
        return;
      }

      await fs.ensureDir(webDirPath);
      const files = await this.getAllMarkdownFiles(vaultDirPath);
      
      for (const file of files) {
        await this.convertVaultFileToWebContent(file, webDirPath);
      }
      
    } catch (error) {
      console.error(`❌ Error processing ${vaultDir}:`, error.message);
    }
  }

  async convertVaultFileToWebContent(filePath, outputDir) {
    try {
      const content = await fs.readFile(filePath, 'utf8');
      const parsed = matter(content);
      
      // Extract metadata
      const productName = this.extractProductName(parsed.data, content);
      const techAreas = this.extractTechAreas(parsed.data);
      
      // Create web-friendly metadata
      const webMetadata = {
        title: this.generateWebTitle(parsed.data, filePath),
        description: this.generateDescription(parsed.content),
        product: productName,
        technologies: techAreas,
        status: parsed.data.status || 'active',
        lastUpdated: new Date().toISOString(),
        originalPath: path.relative(this.vaultPath, filePath)
      };
      
      // Process markdown content
      const processedContent = this.processMarkdownForWeb(parsed.content);
      
      // Generate output filename
      const webFileName = this.generateWebFileName(filePath, productName);
      const outputPath = path.join(outputDir, webFileName);
      
      // Create the web content file
      const webContent = matter.stringify(processedContent, webMetadata);
      await fs.writeFile(outputPath, webContent);
      
      console.log(`  📄 ${path.basename(filePath)} → ${webFileName}`);
      
    } catch (error) {
      console.error(`❌ Error converting ${filePath}:`, error.message);
    }
  }

  async generateProductOverview() {
    const products = [
      {
        name: 'Insight',
        description: 'Advanced Beyblade performance analytics and training insights',
        status: 'active'
      },
      {
        name: 'Catalyst', 
        description: 'Programmable launching system for consistent training and strategy testing',
        status: 'active'
      },
      {
        name: 'Axis',
        description: 'Machine vision system for objective battle analysis and verification',
        status: 'planning'
      }
    ];

    const overviewContent = `# Inertia Product Ecosystem

The Inertia ecosystem consists of three integrated products that revolutionize Beyblade training and competition:

${products.map(product => `
## ${product.name}
${product.description}

**Status:** ${product.status}

[Learn more about ${product.name}](/products/${product.name.toLowerCase()})
`).join('\n')}

## How They Work Together

The Inertia ecosystem creates a complete training and competition environment:

1. **Insight** measures and analyzes your technique
2. **Catalyst** provides consistent training opponents
3. **Axis** verifies competition results objectively

Together, they transform Beyblade from intuition-based to data-driven performance.
`;

    const metadata = {
      title: 'Inertia Product Ecosystem',
      description: 'Complete overview of Inertia\'s Beyblade training and competition products',
      type: 'overview',
      lastUpdated: new Date().toISOString()
    };

    const outputPath = path.join(this.contentPath, 'products', 'overview.md');
    await fs.writeFile(outputPath, matter.stringify(overviewContent, metadata));
    
    console.log('📦 Generated product overview');
  }

  async generateHomePage() {
    const homeContent = `# Welcome to Inertia

## Transforming Beyblade Through Data

Inertia brings scientific precision to the art of Beyblade. Our ecosystem of connected devices and software transforms every launch, every battle, and every training session into actionable insights.

## The Future of Competitive Beyblade

- **Objective measurement** replaces guesswork
- **Consistent training** accelerates improvement  
- **Verified competition** ensures fair play
- **Global community** connects all players

[Explore Our Products](/products) | [Learn the Technology](/technology)

## Latest Updates

Check out our latest developments and insights from the Inertia team.

[View Blog](/blog)
`;

    const metadata = {
      title: 'Inertia - Data-Driven Beyblade Performance',
      description: 'Transform your Beyblade training with precision measurement, consistent practice, and objective competition verification.',
      type: 'homepage',
      lastUpdated: new Date().toISOString()
    };

    const outputPath = path.join(this.contentPath, 'home.md');
    await fs.writeFile(outputPath, matter.stringify(homeContent, metadata));
    
    console.log('🏠 Generated homepage content');
  }

  // Helper methods
  extractProductName(frontmatter, content) {
    if (frontmatter.product) return frontmatter.product;
    
    const products = ['Insight', 'Catalyst', 'Axis'];
    for (const product of products) {
      if (content.includes(product)) return product;
    }
    return null;
  }

  extractTechAreas(frontmatter) {
    if (frontmatter.technology) return frontmatter.technology;
    return ['electronics', 'software'];
  }

  generateWebTitle(frontmatter, filePath) {
    if (frontmatter.title) return frontmatter.title;
    
    const basename = path.basename(filePath, '.md');
    return basename.replace(/[-_]/g, ' ')
      .replace(/\b\w/g, char => char.toUpperCase());
  }

  generateDescription(content) {
    // Extract first paragraph as description
    const firstParagraph = content.split('\n\n')[0];
    return firstParagraph.replace(/[#*`]/g, '').trim().substring(0, 160);
  }

  processMarkdownForWeb(markdown) {
    return markdown
      // Convert Obsidian links to web links
      .replace(/\[\[([^\]]+)\]\]/g, (match, linkText) => {
        const webPath = this.convertObsidianLinkToWeb(linkText);
        return `[${linkText}](${webPath})`;
      })
      // Clean up vault-specific syntax
      .trim();
  }

  convertObsidianLinkToWeb(obsidianLink) {
    // Convert vault links to website paths
    if (obsidianLink.includes('Products/Insight')) return '/products/insight';
    if (obsidianLink.includes('Products/Catalyst')) return '/products/catalyst';
    if (obsidianLink.includes('Products/Axis')) return '/products/axis';
    if (obsidianLink.includes('Technology')) return '/technology';
    
    return `#${obsidianLink.toLowerCase().replace(/\s+/g, '-')}`;
  }

  generateWebFileName(originalPath, productName) {
    const basename = path.basename(originalPath, '.md');
    let slug = basename.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
    
    // Avoid duplicate product names in filename
    if (productName && !slug.includes(productName.toLowerCase())) {
      slug = `${productName.toLowerCase()}-${slug}`;
    }
    
    return `${slug}.md`;
  }

  async getAllMarkdownFiles(dirPath) {
    const files = [];
    
    const scan = async (currentPath) => {
      try {
        const items = await fs.readdir(currentPath, { withFileTypes: true });
        
        for (const item of items) {
          const fullPath = path.join(currentPath, item.name);
          
          if (item.isDirectory()) {
            await scan(fullPath);
          } else if (item.name.endsWith('.md')) {
            files.push(fullPath);
          }
        }
      } catch (error) {
        // Directory might not exist, skip silently
      }
    };
    
    await scan(dirPath);
    return files;
  }
}

// Main execution
async function main() {
  const bridge = new InertiaContentBridge();
  await bridge.syncVaultToWebsite();
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

module.exports = InertiaContentBridge;